[ 03 화면을 개발하기 위한 필수 단위 – 인스턴스 & 컴포넌트 ]
  03-1 뷰 인스턴스
    ■ 뷰 인스턴스(Instance): 화면을 개발하기 위해 필수적으로 생성해야 하는 기본 단위
	  . 생성: new Vue({ ... });  → el 속성: 뷰 인스턴스가 그려질 지점을 지정 | data 속성: message 값을 정의하여 화면의 {{message}}에 연결
	  . 생성자: new Vue()로 인스턴스를 생성할 때 Vue를 생성자라고 함.
        → 뷰로 개발할 때 필요한 기능들을 생성자에 미리 정의해 놓고 사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위함.
	□ 뷰 인스턴스 옵션 속성: 인스턴스를 생성할 때 재정의할 data, el, template 등의 속성을 의미
	  1) template: 화면에 표시할 HTML, CSS등의 마크업 요소를 정의하는 속성. 뷰의 데이터 및 기타 속성들도 함께 화면에 그리기 가능
	  2) methods: 화면 조직 제어와 관계된 메서드를 정의하는 속성. 마우스 클릭 이벤트 처리와 같은 화면의 전반적인 이벤트와 화면 동작과 관련된 로직을 추가 가능
	  3) created : 뷰 인스턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성
	□ 뷰 인스턴스의 유효 범위: 뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션 속성들이 적용되어 나타는 것
	  . 인스턴스가 화면에 적용되는 과정
	    뷰 라이브러리 파일 로딩 → 인스턴스 객체 생성(옵션 속성 포함) → 특정 화면 요소에 인스턴스를 붙임 → 인스턴스 내용이 화면 요소로 변환 → 변환된 화면 요소를 사용자가 최종 확인
	□ 뷰 인스턴스 라이프 사이클
	  1) beforeCreate: 인스턴스가 생성되고 나서 가장 처음으로 실행되는 단계
	  2) created: beforeCreate 다음으로 실행. data, methods 속성이 정의되어 있어 정의된 값에 접근하여 로직을 실행 ( template 속성에 정의된 돔 요소는 접근 불가 )
	  3) beforeMount: template 속성에 지정한 마크업 속성을 render() 함수로 변환한 후 el 속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계
	  4) mounted: el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계로, template 속성에 정의한 화면 요소(돔)에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋은 단계
	  5) beforeUpdate: 관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계 ( 변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣는 것이 가능 )
	  6) updated: 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계 ( 데이터 변경 후 화면 요소 제어와 관련된 로직을 추가하기 좋은 단계 )
	  7) beforeDestroy: 뷰 인스턴스가 파괴되기 직전에 호출되는 단계 ( 아직 인스턴스에 접근할 수 있어 뷰 인스턴스의 데이터를 삭제하기 좋은 단계 )
	  8) destroyed: 뷰 인스턴스가 파괴되고 나서 호출되는 단계 ( 뷰 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스 또한 모두 파괴 )
  03-2 뷰 컴포넌트
    ■ 컴포넌트(Component): 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미
	  . 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발 가능
	    ※ 뷰에서는 내비게이션 바(navigation bar), 테이블(table), 리스트(list), 인풋 박스(input box) 등과 같은 화면 구성 요소들을 잘게 쪼개어 관리
	□ 컴포넌트 등록하기
	  1) 전역(Global) 컴포넌트: 여러 인스턴스에서 공통으로 사용 가능  → Vue.component('컴포넌트 이름', { // 컴포넌트 내용 });
	    . 전역 컴포넌트가 화면에 나타나기까지의 처리 과정: 뷰 라이브러리 파일 로딩 → 뷰 생성자로 컴포넌트 등록 = Vue.component() → 인스턴스 객체 생성(옵션 속성 포함) → 특정 화면 요소에 인스턴스 부착 → 인스턴스 내용 변환(등록된 컴포넌트 내용도 변환): <my-component>가 <div>로 변환 → 변환된 화면 요소를 사용자가 최종 확인
	  2) 지역(Local) 컴포넌트: 특정 인스턴스에서만 유효한 범위를 가짐  → new Vue({ components: { '컴포넌트 이름': 컴포넌트 내용 } });
	□ 지역 컴포넌트와 전역 컴포넌트의 차이
	  . 전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components 속성으로 등록할 필요 없이 한 번 등록하면 어느 인스턴스에서든지 사용 가능
	  . 반대로 지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록이 필요
  03-3 뷰 컴포넌트 통신
    ■ 컴포넌트 간 통신과 유효 범위: 컴포넌트로 화면을 구성하므로 같은 웹 페이지라도 데이터 공유가 불가
	  . 자체적으로 고유한 유효 범위(Scope)를 갖기에, 각 컴포넌트의 유효 범위가 독립적이라 다른 컴포넌트의 값을 직접적으로 참조 불가
	□ 상·하위 컴포넌트 관계: 기본적인 데이터 전달 방법은 상위(부모) - 하위(자식) 컴포넌트 간의 데이터 전달
	  . 상위에서 하위로는 props라는 특별한 속성을 전달하며 하위에서 상위로는 기본적으로 이벤트만 전달 가능
	□ 상위에서 하위 컴포넌트로 데이터 전달하기
	  . props 속성: 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 사용하는 속성  → Vue.component('child-component', { props: ['props 속성 이름'], });
        ※ 인스턴스에 새로운 컴포넌트를 등록하면 기존에 있는 컴포넌트는 상위 컴포넌트(부모)가 되고, 새로 등록된 컴포넌트는 하위(자식) 컴포넌트가 됨. → 새 컴포넌트를 등록한 인스턴스는 최상위 컴포넌트(Root Component)
	□ 하위에서 상위 컴포넌트로 이벤트 전달하기
	  . 이벤트 발생(event emit)과 수신: 상위 컴포넌트에서 하위 컴포넌트의 특정 이벤트가 발생하기를 기다리고 있다가 하위 컴포넌트에서 특정 이벤트가 발생하면 상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메서드를 호출
	    1) 이벤트 발생: this.$emit('이벤트명');
		2) 이벤트 수신: <child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child-component>
	□ 같은 레벨의 컴포넌트 간 통신
	  . 뷰는 상위에서 하위로만 데이터를 전달해야 하는 기본적인 통신 규칙을 따르기 때문에 바로 옆 컴포넌트에 값을 전달 하려면 하위에서 공통 상위 컴포넌트로 이벤트를 전달한 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트에 props를 내려 보내야 함
        → 같은 레벨 간에 통신하기 위해 강제로 상위 컴포넌트를 두는 것을 해결할 수 있는 방법 = 이벤트 버스
	□ 관계 없는 컴포넌트 간 통신 – 이벤트 버스
	  . 이벤트 버스(Event Bus): 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고받을 수 있는 방법
	    → 로직을 담는 인스턴스와는 별개로 새로운 인스턴스를 1개 더 생성하고, 새 인스턴스를 이용하여 이벤트를 주고 받음 [ 보내는 컴포넌트에서는 .$emit()을, 받는 컴포넌트에서는 .$on()을 구현 ]
		  1) 이벤트 버스를 위한 추가 인스턴스 1개 생성: var eventBud = new Vue();
		  2) 이벤트를 보내는 컴포넌트: methods: { 메서드명: function() { eventBus.$emit('이벤트명', 데이터); } }
		  3) 이벤트를 받는 컴포넌트: methods: { created: function() { eventBus.$on('이벤트명', function(데이터) { ... }); } }
      . props 속성을 이용하지 않고도 원하는 컴포넌트 간에 직접적으로 데이터를 전달할 수 있어 편리하지만 컴포넌트가 많아지면 어디서 어디로 보냈는지 관리가 되지 않는 문제가 발생
	    → 문제 해결을 위해 뷰엑스(Vuex)라는 상태 관리 도구가 필요 ( 간략한 소개는 7장 참고 )


3장 인스턴스 & 컴포넌트

1. Vue 인스턴스 속성
 1) data : data 부분
 2) el : html id를 가진 요소를 의미함
 3) template : 화면에 표시할 html, css 등의 태그 요소를 정의하는 속성
 4) methods : 화면 로직의 제어와 관계된 메소드를 정의하는 속성 (이벤트 처리와 같은 로직)
 5) created : 뷰 인스턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성

2. 뷰 인스턴스 라이프 사이클
 1) 인스턴스 생성 → 인스턴스를 화면에 부착
  1> beforeCreate : 인스턴스가 생성되고 나서 가장 처음으로 실행되는 단계 (data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않고 돔과 같은 화면 요소에도 접근할 수 없음)
  2> created : data 속성과 methods 속성에 정의도니 값에 접근하여 로직을 실행할 수 있는 단계 (서버에 데이터를 요청하여 받아오는 로직을 수행하기 좋은 단계)
  3> beforeMount : template 속성을 el에 지정한 화면 요소에 인스턴스를 부착하기 직전 단계
  4> mounuted : el 속성에 지정한 화면 요소에 인스턴스가 부착되고 호출되는 단계로 template 속성에 정의한 화면 요소에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋은 단계

 2) 인스턴스를 화면에 부착 → 인스턴스 내용 갱신
  1> beforeUpdate : 인스턴스에 정의한 속성이 화면에 치환되는 단계 (데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계, 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있음)
  2> update : 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계

 3) 인스턴스 내용 갱신 → 인스턴스 소멸
  1> beforeDestroy : 뷰 인스턴스가 파괴되기 직전에 호출되는 단계 (인스턴스에 접근할 수 있음, 데이터를 삭제하기 좋은 단계)
  2> destroyed : 뷰 인스턴스가 파괴되고 나서 호출되는 단계

3. 컴포넌트 : 조합하여 화면을 구성할 수 있는 블록을 의미함
 1) 컴포넌트 등록 방법
  1> 전역 컴포넌트 등록
	Vue.component('my-component', {
       template: '<div> 전역 컴포넌트가 등록되었습니다!</div>'
    });

  2> 지역 컴포넌트 등록
	new Vue({
        components: {
		  // 컴포넌트 이름 : 컴포넌트 내용
          'my-local-component': cmp
        }
	});

4. 하위에서 상위 컴포넌트로 이벤트 전달하기
 1) 이벤트 발생 :
	this.$emit('이벤트명');
 2) 이벤트 수신 :
	<child-component v-on:show-log="printText"></child-component>
	- show-log : 이벤트명
	- printText : 상위 컴포넌트의 메소드명
