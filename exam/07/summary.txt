[ 07 Vue.js 고급 개발자 되기 ]
  07-1 뷰 중·고급 레벨로 올라가기 위한 지식
    ■ 뷰엑스(Vuex): 애플리케이션의 상태 관리를 돕는 라이브러리  → 공식 사이트: https://vuex.vuejs.org/
	  . 상태(state): 특정 데이터를 여러 컴포넌트가 공유하고 있을 때 그 데이터
	    ※ 상태 관리의 목적: 애플리케이션에서 사용하는 모든 데이터를 중앙에서 관리하여 크기가 큰 애플리케이션의 데이터 관리를 효율적으로 하는 것
	□ 뷰의 반응성(Reactivity): 뷰가 데이터 변화를 감지했을 때 자동으로 화면을 다시 갱신하는 특성 ( https://vuejs.org/v2/guide/reactivity.html )
	  . 뷰의 반응성에 대해 알아두면 프레임워크 내부적으로 화면을 그리는 방법, 가상 돔이 동작하는 방법, 화면을 빠르게 그리기 위해 브라우저에 부하를 주지 않고 돔을 추가, 삭제하는 방법을 익힐 수 있음
	  . 진행 순서: 인스턴스 생성 → 생성 시 라이브러리에서 data에 정의된 모든 속성(객체)을 getter, setter의 형태로 변환 → getter, setter는 사용자가 접근할 수 있는 속성이 아니며 라이브러리 내부적으로 필요한 속성 → 화면을 다시 갱신하는 속성인 watcher는 모든 컴포넌트에 존재하는 속성으로, 인스턴스가 화면에 올라가고 나서 특정 data 속성을 바꾸거나 접근하면 watcher에서 해당 사실을 감지한 후 화면 재구성 요청
	    ※ 인스턴스를 정의할 때 data 속성에 정의하지 않고 인스턴스를 생성하고 난 후 data 속성에 객체를 추가하면 그 객체에는 반응성이 생기지 않음  → 반응성이 없다는 것은 해당 객체의 변화와 상관없이 뷰에서 화면을 다시 갱신하지 않는다는 의미
	□ 서버 사이드 렌더링(Server Side Rendering): 완벽히 그려진 HTML 페이지를 브라우저에서 받는 것을 의미 ( 검색 엔진 최적화와 초기 화면 렌더링 속도가 강점 )
	  . 클라이언트 사이드 랜더링: 웹 페이지를 화면에 그릴 때 그리는 동작을 클라이언트(브라우저)에서 수행 ( 매끄러운 화면 전환과 사용자 경험의 향상이라는 장점 보유 )
	  . 서버 사이드 렌더링 세부사항 및 라이브러리(Nuxt.js) 정보: https://ssr.vuejs.org/  |  https://nuxtjs.org/
  07-2 뷰 개발을 위한 웹팩
    ■ 웹팩: 모듈 번들러라고 알려져 있으며, 서로 연관이 있는 모듈 간의 관계를 해석하여 정적인 자원으로 변환해 주는 변환 도구
	  . 화면 구성에 필요한 파일(자바스크립트/CSS/이미지)마다 서버로 보내는 HTTP 요청이 발생하는 데, HTTP 네트워크 요청 숫자가 늘어날수록 웹 화면 로딩 시간은 길어질 수 밖에 없기에 동작에 관련된 여러 파일들을 1개의 자바스크립트 파일 안에 넣고, 해당 자바스크립트 파일만 로딩해도 웹 앱이 돌아가게 하자는 취지
	□ 웹팩의 주요 속성
	  . entry: 웹팩으로 빌도할 대상 파일을 지정하는 속성. entry로 지정한 파일의 내용에는 전체 애플리케이션 로직과 필요 라이브러리를 로딩하는 로직이 들어감
      . output: 웹팩으로 빌드한 결과물의 위치와 파일 이름 등 세부 옵션을 설정하는 속성
      . loader: 웹팩으로 빌드할 때 HTML, CSS, PNG파일 등의 자바스크립트로 변환하기 위해 필요한 설정을 정의하는 속성
      . plugin: 웹팩으로 빌드하고 나온 결과물에 대해 추가 기능을 제공하는 속성. 결과물의 사이즈를 줄이거나 결과물을 기타 CSS, HTML 파일로 분리하는 기능 등
      . resolve: 웹팩으로 빌드할 때 해당 파일이 어떻게 해석되는지 정의하는 속성. 특정 라이브러리를 로딩할 때 버전은 어떤걸로 하고, 파일 경로는 어디로 지정하는지 등을 정의
	□ 웹팩 데브 서버(Webpack-dev-server): 웹팩 설정 파일의 변화를 감지하여 빠르게 웹팩을 빌드할 수 있도록 지원하는 유틸리티이자 노드제이에스(Node.js) 서버
	  . 웹팩 설정 파일(webpack.config.js)의 내용이 변경되면 브라우저 화면을 자동으로 새로 고침하고, 바로 다시 웹팩으로 빌드하는 기능을 보유
	  . 빌드한 결과물을 파일 시스템에 저장하지 않고 컴퓨터 메모리에 저장 ( 인 메모리 기반 )
	□ webpack-simple 프로젝트의 웹팩 설정 파일 분석
      . 파일 경로와 웹팩 라이브러리 로딩: output 속성에서 사용할 노드 path 라이브러리와 웹팩 플러그인에서 사용할 node_modules의 웹팩 라이브러리를 node_modules 폴더에서 로딩하여 path, webpack에 각각 저장
	  . entry 속성: 웹팩으로 빌드할 파일을 src 폴더 및의 main.js 파일로 지정. main.js 파일에 정의한 내용에 따라 애플리케이션의 구성 요소 및 파일들이 웹팩으로 번들링(빌드)됨
	  . output 속성: 웹팩으로 빌드하고 난 결과물 파일의 위치와 이름을 지정. → 결과물 파일의 위치: dist/build.js
	  . module 속성: 웹팩으로 애플리케이션 파일들을 빌드(변환)할 때 HTML, CSS, PNG 등의 파일을 자바스크립트로 변환해 주는 로더를 지정
	  . resolve 속성: 웹팩으로 빌드할 때 사용할 뷰 라이브러리 유형을 지정. vue.esm.js는 최신 웹팩 버전과 사용할 수 있는 풀 버전의 라이브러리를 의미하며, 별도로 설정하지 않으면 런타임 버전인 vue.runtime.sem.js를 사용
	  . devServer 속성: 웹팩 데브 서버 관련 속성을 지정
        - historyApiFallback 속성: 클라이언트 사이드 라우팅인 뷰 라우터와 함께 사용하기 위해 true로 지정
        - noInfo 속성: 처음 서버를 시작할 때만 웹팩 빌드 정보를 보여주고, 이후 변경 시에는 빌드 정보를 보여주지 않음
	    - overlay 속성: 웹팩으로 빌드할 때 오류가 있으면 브라우저 화면 전체에 오류를 표시
	  . performance 속성: 웹팩으로 빌드한 파일의 크기가 250kb를 넘으면 경고 메시지를 표시할지를 설정. hints가 false이므로 크기와 관계 없이 경고가 표시되지 않음
	  . devtool 속성: 웹팩으로 빌드된 파일로 웹 앱을 구동했을 때 개발자 도구에서 사용할 디버깅 방식을 지정
        ※ 옵션에 대한 상세 내용: https://webpack.js.org/configuration/devtool/
	  . 배포 옵션: 개발자 도구 분석 옵션을 #source-map으로 지정하고, 자바스크립트 파일의 크기를 줄이는 Uglify 플러그인과 환경 변수 값을 설정
  07-3 뷰 개발을 위한 ES6
    ■ ES6(ECMAScript 2015): 최신 자바스크립트 문법이자 스펙으로, 개발자가 더 쉽게 코드를 작성할 수 있도록 문법을 단순화하고 미숙한 코딩으로 인한 오류를 미연에 방지하기 위해 언어 자체에 유효 범위를 제한하는 등의 기능을 추가
	□ const와 let 예약어: const와 let은 변수를 선언할 때 사용하는 예약어
      . ES5에서는 변수를 선언할 때 var를 사용하지만 ES6는 var 대신 let으로 변수를 선언. 또한 선언한 후 값이 바뀌지 않고 동일하게 사용되는 변수에 대해서는 const를 추가로 사용
	    ※ const와 let 차이: let로 선언된 변수는 할당된 값을 변경할 수 있어서 console 창에 변경된 값으로 출력이 되지만, const로 선언된 변수는 할당된 값을 변경할 수 없어 TypeError 오류가 표시
	□ 블록의 유효 범위
	  . ES5를 사용한 문법에서는 for 블록 밖에 변수 i를 선언하였지만 for 문의 반복 조건에서 변수 i를 선언하여 변수를 사용 → for 문이 끝난 블록 밖에서 변수 i를 출력하면 값이 10이 아닌 5가 출력
	  . 이러한 문제점을 ES6에서 개선: let 예약어를 사용하여 변수를 선언한 후, i 변수의 값을 출력한 결과 10이 출력되어 위에서 발생한 문제점이 해결됨
	□ 화살표 함수: 기존 ES5의 함수 정의 방식을 간소화한 문법
      . 인자 값 2개를 합산하는 함수 표현식으로, 함수를 선언할 때 function()으로 길게 선언할 필요 없이 =>로 간단하게 선언 가능 ( 장점: 구현속도도 빨라지고 코드의 전체 길이도 짧아짐 )
	□ Import와 Export: 자바스크립트 모듈화와 관련된 기능 ( 모듈화: 코드를 특정 기능이나 로직 단위로 구분하여 각각의 모듈로 관리하는 것 )
	  . import: 한 파일에서 다른 파일의 내용을 불러올 때 사용  → main.js 파일에서 import를 사용하여 login.js 파일에 있는 id의 값을 불러와서 사용
	  . export는 한 파일의 특정 기능을 다른 파일에서 사용할 수 있도록 설정할 때 사용  → login.js 파일에 있는 id 변수를 export를 사용하여 다른 파일에서 사용할 수 있도록 설정
  07-4 뷰 CLI에서 사용하는 NPM
    □ NPM(Node Package Manager): 전 세계 자바스크립트 라이브러리가 존재하는 공개 저장소
	□ NPM 설치 명령어: 가장 흔하게 사용되는 명령어는 npm installnpm install
	  . 해당 명령어를 명령 프롬프트 창에 입력하여, npm 설정 파일(package.json)에 설정된 라이브러리 목록을 다운로드
	    ※ --save 옵션과 --save-dev 옵션: 웹팩 추가 설정을 위한 플러그인 라이브러리나 로직과 관련된 외부 라이브러리를 해당 프로젝트에 다운로드하는 옵션
		  1) npm install --save: dependencies 속성에 라이브러리 이름이 추가 ( 애플리케이션을 동작시키는 데 필요한 라이브러리가 들어가는 곳 )
		  2) npm install --save-dev: devDependencies 속성에 라이브러리 이름이 추가 ( 애플리케이션을 개발할 때 필요한 라이브러리가 들어가는 곳 )

		  	□ 전역 설치와 지역 설치
	  . 전역 설치: -global 옵션을 이용해 해당 라이브러리를 시스템 레벨에 설치하는 것 ( -global을 -g로 줄일 수 있으며, install 역시 i로 줄일 수 있음 )
	  . 지역 설치: --save, --save-dev 같이 해당 프로젝트에 설치하는 것 ( node_modules 폴더가 추가됨 )
	□ NPM 커스텀 명령어: 'npm run 명령어' 형식으로 사용을 위해 npm 설정 파일(package.json)의 scripts 속성에 원하는 명령어 추가 및 옵션 정의
	  → npm run build 명령어는 웹팩으로 프로젝트를 빌드할 때 사용했고, npm run dev 명령어는 프로젝트를 웹팩 데브 서버로 구동할 때 사용함
	    . "dev" : "cross-env NODE_ENV=development webpack-dev-server --open --hot",
	    . "build" : "cross-env NODE_ENV=production webpack --progress --hide-modules"

[ 현장 밀착 취재 - 지금 당장 실무에서 써먹는 Vue.js ]
  Tip 1 뷰와 제이쿼리를 같이 사용해도 되나요?
    ■ 뷰에서 제이쿼리는 필요 없음: 뷰에서도 화면의 요소를 쉽게 접근할 수 있는 ref 속성을 제공하며, 특정 요소 이벤트도 v-on 디렉티브로 처리 가능
	  → 제이쿼리에서 구현할 수 있는 기능이라면 뷰에서도 모두 구현 가능하므로 굳이 제이쿼리를 함께 사용할 필요는 없음
	□ 뷰의 인스턴스 라이프 사이클을 정확히 이해하지 못한 상태에서 제이쿼리를 함께 사용하면 오류가 발생
	  → 뷰와 제이쿼리의 화면 요소 접근 방식에는 서로 차이가 있기 때문에 혼용하지 않는 것이 좋음
  Tip 2 개발 기간이 너무 짧은데 기존 레거시 코드에 어떻게 뷰를 바로 적용하죠?
    ■ 개발 기간이 충분하지 않은 상태에서 뷰로 제이쿼리 UI와 유사한 라이브러리를 만드는 것은 오래 걸림 → 기존 라이브러리를 안전하게 뷰에서 사용할 수 있도록 통합 필요
	□ 제이쿼리와 제이쿼리 UI 라이브러리 연동
	  . CDN을 이용하는 방법: index.html 파일에 <script> 추가 → 검색 엔진에 jquery cdn과 jquery ui cdn을 입력하여 검색
	  . 웹팩 추가 플로그인을 사용하는 방법: 웹팩 설정 파일(webpack.config.js)에 ProvidePlugin 설정 추가
	□ 제이쿼리 UI 라이브러리의 날짜 선택기 위젯 구현: 인스턴스 라이프 사이클 훅 중 mounted에 제이쿼리 로직을 추가
	□ 날짜 선택기 위젯 컴포넌트화: src 폴더 밑에 DatePicker.vue 파일을 생성하고 날짜 선택기 코드 부분을 가져와 추가 후, DatePicker.vue 파일을 App.vue 파일의 지역 컴포넌트로 등록
  Tip 3 뷰에 UI 라이브러리와 차트를 어떻게 연동할까요?
    ■ 뷰-부트스트랩 라이브러리 사용: https://bootstrap-vue.org/  → [Docs > Getting Started] 참고
	□ 뷰와 일반 부트스트랩 라이브러리 연동: 부트스트랩 라이브러리는 CDN으로 로딩 ( http://bootstrapk.com/getting-started/#download-cdn )
	  1) 부트스트랩 CSS CDN은 head의 <link>에 자바스크립트 CDN은 body의 <script>에 추가
	  2) App.vue에 기존 코드를 정리하고, 부트스트랩 추가 코드를 삽입
	□ 뷰와 차트 라이브러리 연동: 앞서 진행한 뷰와 일반 부트스트랩 라이브러리 연동에 하이 차트(HighChart) 연동 ( https://www.highcharts.com/ )
      1) body의 <script>에 하이 차트의 CDN 주소를 추가 ( https://www.highcharts.com/docs/getting-started/installation )
	  2) src 폴더 밑에 Chart.vue 파일을 새로 생성하고 코드 추가  ← 공식 사이트의 막대(bar)차트의 샘플 이용
	  3) App.vue에서 Chart.vue를 컴포넌트로 등록하고 <template>에 컴포넌트 태그를 추가
  Tip 4 뷰로 프로그레시브 웹 앱을 개발하려면 어떻게 시작해야 하죠?
    ■ 프로그레시브 웹 앱(PWA, Progressive Web App): A new way to deliver amazing user experiences on the web.
	  → 사용자에게 편의성을 제공하기 위해 빠른 성능과 애플리케이션 아이콘, 애플리케이션 설치, 푸시 알람 기능을 제공하는 웹 앱
	□ 뷰로 프로그레시브 웹 앱 구현: 웹 앱 매니페스트(web app manifest) 파일과 서비스 워커(service worker)라는 주제 공부 필요
	  . 뷰 CLI를 이용하여 프로젝트 구성: vue init pwa ( 프로젝트 정보는 기본 값을 활용하고, 추가 라이브러리는 미설치 )
	  . 프로그래시브 웹 앱 공식 문서: https://web.dev/progressive-web-apps/
